\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}




% A package for setting layout and margins for your thesis 
\usepackage[a4paper]{geometry}

\usepackage[T1]{fontenc}
% Use package babel for English or Estonian 
% If you use Estonian make sure that Estonian hyphenation is installed 
% - hypen-estonian or eehyp packages
\usepackage[estonian, english]{babel}

\usepackage[backend=biber,
			sorting=none]{biblatex}
			

\addbibresource{crumblepy.bib}

\input{ut-style.tex}

%\usepackage{babelbib}

% \usepackage[english]{babel}
% \usepackage[estonian]{babel}


% General packages for math in general, theorems and symbols 
% Read ftp://ftp.ams.org/ams/doc/amsmath/short-math-guide.pdf for further information
\usepackage{amsmath} 
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{ltxtable}

\usepackage{tabularx}
\usepackage{longtable}

\usepackage{forest}

\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}

\usepackage{caption}
% Optional calligraphic fonts    
% \usepackage[mathscr]{eucal}

% Packages for building tables and tabulars 
\usepackage{array}
\usepackage{tabu}   % Wide lines in tables
\usepackage{xspace} % Non-eatable spaces in macros

% Including graphical images and setting the figure directory
\usepackage{graphicx}
\graphicspath{{figures/}}

% Packages for getting clickable links in PDF file



% Packages for defining colourful text together with some colours
\usepackage{color}
\usepackage{xcolor} 
%\definecolor{dkgreen}{rgb}{0,0.6,0}
%\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}


\usepackage{tocloft}
\usepackage{enumitem}

% Standard package for drawing algorithms
% Since the thesis in article format we must define \chapter for
% the package algorithm2e (otherwise obscure errors occur) 
\let\chapter\section
\usepackage[ruled, vlined, linesnumbered]{algorithm2e}

% Fix a  set of keywords which you use inside algorithms
\SetKw{True}{true}
\SetKw{False}{false}
\SetKwData{typeInt}{Int}
\SetKwData{typeRat}{Rat}
\SetKwData{Defined}{Defined}
\SetKwFunction{parseStatement}{parseStatement}


% Nice todo notes
\usepackage{todonotes}


% Proper way to create coloured code listings
\usepackage{bigfoot}
\usepackage{listings}
\lstset{ 
  language=python,
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  %numbers=left,                   % where to put the line-numbers
  %numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
  numberstyle=\tiny\color{gray}, 
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line 
                                   % will be numbered
  numbersep=5pt,                   % how far the line-numbers are from the code
  backgroundcolor=\color{white},   % choose the background color. You must add \usepackage{color}
  showspaces=false,                % show spaces adding particular underscores
  showstringspaces=false,          % underline spaces within strings
  showtabs=false,                  % show tabs within strings adding particular underscores
  frame = lines,
  %frame=single,                   % adds a frame around the code
  rulecolor=\color{black},		   % if not set, the frame-color may be changed on line-breaks within 
                                   % not-black text (e.g. commens (green here))
  tabsize=2,                       % sets default tabsize to 2 spaces
  captionpos=b,                    % sets the caption-position to bottom
  breaklines=true,                 % sets automatic line breaking
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  %title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                   % also try caption instead of title
                                   % also try caption instead of title
  keywordstyle=\color{blue},       % keyword style
  commentstyle=\color{dkgreen},    % comment style
  stringstyle=\color{mauve},       % string literal style
  escapeinside={\%*}{*)},          % if you want to add a comment within your code
  morekeywords={*,game, fun}       % if you want to add more keywords to the set
}

\usepackage{minted}
\setminted{fontfamily=courier, python3=true, fontsize=\footnotesize}
\newminted{python}{}
\newmintinline[python]{python}{}
\newmintinline[textinline]{text}{}
\newmintedfile{python}{}
\newmintedfile{text}{}
%\lstMakeShortInline[columns=fixed]|

\usepackage [autostyle]{csquotes}
% Nice Todo box
\newcommand{\TODO}{\todo[inline]}


\selectlanguage{estonian}




\usepackage[hypertexnames=false]{hyperref}
\usepackage[all]{hypcap}

\emergencystretch=1em

%%% BEGIN DOCUMENT
\begin{document}

% BEGIN TITLE PAGE
\thispagestyle{empty}
\begin{center}

\large
TARTU ÜLIKOOL\\[2mm]
Arvutiteaduse teaduskond\\
Informaatika õppekava\\[2mm]

%\vspace*{\stretch{5}}
\vspace{25mm}

\Large Rasmus Saks

\vspace{4mm}

\huge Crumble kontrollerile Pythoni-laadse programmeerimiskeele loomine

%\vspace*{\stretch{7}}
\vspace{20mm}

\Large Bakalaureustöö (9 EAP)

\end{center}

\vspace{2mm}

\begin{flushright}
 {
 \setlength{\extrarowheight}{5pt}
 \begin{tabular}{r l} 
  \sffamily Juhendaja: & \sffamily Aivar Annamaa
 \end{tabular}
 }
\end{flushright}

%\vspace*{\stretch{3}}
\vspace{10mm}

%{\noindent Author: .................................................................................... ``.....'' ..........\hskip16pt 2048}
\vspace{2mm}


%{\noindent Supervisor: ............................................................................... ``.....'' ..........\hskip16pt 2048}

\vspace{2mm}

%{\noindent Supervisor: ............................................................................... ``.....'' ..........\hskip16pt 2048}

\vspace{8mm}


\vfill
\centerline{Tartu 2017}

% END TITLE PAGE

% If the thesis is printed on both sides of the page then 
% the second page must be must be empty. Comment this out
% if you print only to one side of the page comment this out
%\newpage
%\thispagestyle{empty}    
%\phantom{Text to fill the page}
% END OF EXTRA PAGE WITHOUT NUMBER

% COMPULSORY INFO PAGE
\newpage

\noindent\textbf{\large Crumble kontrollerile Pythoni-laadse programmeerimiskeele loomine}
\vspace*{3ex}

\noindent\textbf{Lühikokkuvõte:} 
Crumble on Redfern Electronics'i loodud trükkplaat, millega on võimalik juhtida sellega ühendatud elektroonikakomponente. Crumble'it on võimalik programmeerida visuaalses programmeerimiskeeles erinevaid plokke kui pusletükke kokku vedades. Selline lähenemine ei ole õpilasele edasist õppimist toetav, sest reaalses elus kasutatakse visuaalsete programmeerimiskeelte asemel tekstipõhiseid. Käesoleva töö eesmärgiks on luua Pythonil põhinev programmeerimiskeel Crumble kontrolleri juhtimiseks. Loodud keeles kirjutatud programme on võimalik arvutis kompileerida ning otse Crumble kontrollerisse läbi USB ühenduse saata.
\vspace*{3ex}

\noindent\textbf{Võtmesõnad:} Crumble, Python, programmeerimiskeel, riistvara
\vspace*{3ex}

\noindent\textbf{CERCS:} P170 (Arvutiteadus, arvutusmeetodid, süsteemid, juhtimine (automaatjuhtimisteooria))
\vspace*{6ex}

\selectlanguage{english}
\noindent\textbf{\large Creating a Python-like Programming Language for the Crumble Controller}
\vspace*{3ex}
{\flushleft{\textbf{Abstract:}} }

Crumble is a printed circuit board created by Redfern Electronics, which can be used to control electronics components attached to it. It is possible to program Crumble in a visual programming language by dragging together different blocks of code in a puzzle-like manner. This approach however is not very supportive towards a student's further studies in programming, because in real life visual programming languages are basically nonexistent, almost all programs are written in text. The aim of this thesis is to create a programming language based on Python for the Crumble controller. One would be able to compile programs written in the language on their computer and send them directly over USB to the Crumble controller.

\vspace*{3ex}
{\flushleft{\textbf{Keywords:}}} Crumble, Python, programming language, hardware
\vspace*{3ex}

\noindent\textbf{CERCS:} P170 (Computer science, numerical analysis, systems, control)



\newpage
\selectlanguage{estonian}
\tableofcontents



\section*{Sissejuhatus}
\addcontentsline{toc}{section}{Sissejuhatus}
Tänapäeval on tehnika lahutamatu osa inimeste eludest. Üha rohkem ja varajasemast east õpetatakse koolides lastele programmeerimist, kuid tihti jääb programmeerimise seos riistvaraga tähelepanuta. Selle probleemiga tegelemiseks on loodud mitmeid riistvarakomplekte, mida on võimalik küllaltki lihtsasti ka põhikooliõpilasel kokku panna ning arvuti abil programmeerida käituma vastavalt oma soovile. Üks sellistest komplektidest on firma Redfern Electronics loodud Crumble. Crumble võimaldab õpilastel, kes on programmeerimisega juba väheke tuttavad, lihtsa vaevaga ehitada ja programmeerida oma enda füüsiline robot, valgusfoor jne.

Crumble'i probleem seisneb aga liiga algelises ja lihtsas programmeerimiskeeles. Programmeerimiseks veetakse omavahel kokku klotse nagu pusletükke. Selline programmeerimine on algajale lihtne, kuid ei toeta tema edasist arengut, kuna reaalne programmeerimine toimub siiski tekstipõhiselt. Käesoleva töö eesmärgiks on luua Crumble'ile programmeerimiskeel, mis põhineb keelel Python. Kuna Python on paljudes koolides (sh Tartu Ülikoolis) õpilaste esimeseks programmeerimiskeeleks, siis on võimalik selle keele abil siduda Pythoni programmeerimise õppimine riistvara programmeerimisega.

Töö on jaotatud kaheks peatükiks. Esimeses peatükis antakse ülevaade Crumble'ist ning sellega ühilduvatest komponentidest. Teises peatükis tutvustatakse töö raames loodud programmeerimiskeelt Crumblepy.

\section{Crumble}
Crumble on Redfern Electronics’i loodud trükkplaat, millega on võimalik juhtida nii spetsiaalselt Crumble’i jaoks ehitatud sisend-väljundkomponente (koondnimega Crumb’id) kui ka tavalisi elektroonikakomponente ning valgusdioode (vt~\ref{sparkle})~\cite{TheCrumbleController}. Crumb’id erinevad analoogilistest elektroonikakomponentidest selle poolest, et neil on spetsiaalsed Crumble’ile mõeldud pesad. Nende pesade eelised on kirjeldatud peatükis~\ref{sec:kontroller}

Järgnevad peatükid tutvustavad Crumble’i kontrollerit, komponente, mida sellega on võimalik ühendada, ning tarkvara, milles on võimalik luua programme kontrolleril jooksutamiseks.

\subsection{Redfern Electronics’i toodetud originaalkomponendid}
Crumble’ile loovad komponente põhiliselt kaks firmat: Redfern Electronics, kes on Crumble’i originaalautorid, ning 4tronix~\cite{4tronix}. Selle peatüki alampeatükid räägivad olulisematest komponentidest, mida Redfern Electronics toodab ja müüb.

\subsubsection{Kontroller} \label{sec:kontroller}

Kontroller on Crumble’i keskne komponent ning vajalik kõigi teiste komponentide tööks. Sellel on sisemälu ja protsessor, et salvestada jooksutatavat programmi ning juhtida ühendatud komponentide tööd. Kontrolleril on ühendused kahele mootorile, neljale sisend-väljundkomponendile, ühele energiasisendile (nt patareipakist), ühele energiaväljundile (nt valgusdioodile) ning Micro-USB kaablile~\cite{TheCrumbleController}. Joonisel~\ref{fig:basic-connections} on ülevaade Crumble kontrollerist.

\fig[0.9]{basic-connections}{Crumble’i kontrolleri ülevaade~\cite{BasicConnections}.}

Iga kontrolleri pesa on loodud võimaldamaks mitut erinevat ühendusviisi: suur 4mm auk sobib mugavaks ühendamiseks krokodilljuhtmete, elektrit juhtiva niidi või terminalplokiga\footnote{vt ptk~\ref{playground}} ning suur juhtiv pind sobib juhtmete jootmiseks~\cite{TheCrumbleController}.

Kontrolleri saab ühendada Micro-USB pesa kaudu arvutiga, kust on võimalik sellele saata jooksutamiseks programme. Programmide loomiseks on Redfern Electronics loonud spetsiaalse tarkvara, mis kasutab MIT Scratchil~\cite{Scratch-ImagineProgramShare} põhinevat kasutajaliidest. Tarkvarast kirjutatakse lähemalt peatükis~\ref{tarkvara}.

Crumble kontroller võib toidet saada nii arvutist läbi USB ühenduse kui ka muust 4.5 - 5.5 V energiaallikast läbi energiasisendühenduse. Väliseks energiaallikaks sobivad muuhulgas standardsed AA suuruses patareid.

\subsubsection{Crumble-sõbralike komponentide komplekt}

\fig{crumble-friendly-components}{Crumble-sõbralikud komponendid~\cite{crumblefriendlycomponents}.}

Redfern Electronics pakub komplekti kaheksa Crumble-sõbraliku komponendiga~\cite{Crumble-friendlycomponentspack|RedfernElectronics}. See sisaldab endas järgnevaid komponente (joonisel~\ref{fig:crumble-friendly-components} alustades vasakult ülevalt ning liikudes paremale alla): lampi, mikrolülitit\footnote{kahe väljundi vahel lülitatav lüliti~\cite{Snapactionswitches}}, fototakistit, keelreleed\footnote{magnetväljale reageeriv lüliti~\cite{Reedswitches}}, valgusdioodi, tumblerlülitit,  kallutusandur-lülitit ja sumistit. Crumble-sõbralikuks teeb need komponendid asjaolu, et neil on Crumble’iga mugavamaks ühendumiseks spetsiaalsed pesad.

\subsubsection{Ultraheli kaugusandur} \label{kaugusandur}

\fig[0.3]{ultrasonic}{Ultraheli kaugusanduri tagakülg~\cite{HC-SR04backwithCrumbliser}.}

Ultraheli kaugusandur \cite{UltrasonicDistanceMeasuringSensor|RedfernElectronics} võimaldab Crumble programmil mõõta anduri kaugust seinast. Väiksemate objektide kauguse mõõtmiseks ei ole antud kaugusandur sobilik, kuna see vajab ultrahelisignaali tagasipõrkamiseks suurt tasast pinda (nagu sein). Tegemist on HC-SR04~\cite{HCSR04UsersManual} kaugusanduriga, millele on Crumbliser’iga (vt ptk~\ref{crumbliser}) lisatud Crumble ühendused. Alates tarkvara versioonist 0.25.0 on võimalik seda komponenti juhtida ühe käsuplokiga~\cite{UltrasonicDistanceMeasuringSensor|RedfernElectronics}. Joonisel~\ref{fig:ultrasonic} on näha anduri tagakülg koos sellega ühendatud Crumbliser’iga.

\subsubsection{Joonejälitaja}

\fig[0.4]{Line-follower-board}{Joonejälitaja~\cite{Linefollowerboard}.}

Joonejälitaja võimaldab Crumble’i põhjal ehitatud robotil sõita mööda maha märgitud joont. Jälitaja väljastab kaht signaali: üks signaal, kui on tarvis vasakule pöörata, ning teine signaal, kui on tarvis paremale pöörata. Joonisel~\ref{fig:Line-follower-board} on näidatud joonejälitaja. +/- ühendused on sisendenergia jaoks ning L ja R väljundid vastavalt vasakule ja paremale pööramiseks.

\subsubsection{Sparkle} \label{sparkle}

\fig[0.4]{Two-Sparkles-to-Crumble}{Sparkle’ite ühendamine Crumble kontrolleriga~\cite{TwoSparklestoCrumble}.}

Sparkle’iteks~\cite{Sparkles|RedfernElectronics} nimetatakse Crumble’iga ühilduvaid täisvärvides valgusdioode. Need on standardiga WS2812B~\cite{WS2812B} ühilduvad, mis tähendab, et Crumble’iga on võimalik kõiki selle standardi valgusdioode ühendada ning neid individuaalselt juhtida. Erinevalt Sparkle’itele pole selliseid valgusdioode üldjuhul nii lihtne Crumble’iga ühendada, sest neil puuduvad spetsiaalsed pesad juhtmete hoidmiseks. Joonisel~\ref{fig:Two-Sparkles-to-Crumble} on näidatud, kuidas on võimalik mitu Sparkle’it jadamisi ühendada. Crumble tarkvara võimaldab kuni 32 erinevat Sparkle’it individuaalselt juhtida.

\subsubsection{Crumbliser} \label{crumbliser}

\fig[0.4]{Crumblizer-with-WS2812B-Strip}{Crumbliseriga ühendatud WS2812B tüüpi valgusdioodriba~\cite{CrumblizerwithWS2812BStrip}.}

Crumbliser~\cite{CrumbliserRedfernElectronics} on Crumble komponent, mis võimaldab suvalistele elektroonikakomponentidele külge joota Crumble ühendused. Selleks on Crumbliser plaadil neli väiksemat jootmiseks mõeldud ühendust, millest igaüks on ühendatud suurema Crumble-tüüpi ühendusega. Iga ühenduse kõrval on ka valge ala, kuhu saab markeriga meeldetuletuseks kirjutada iga ühenduse otstarbe. Joonisel~\ref{fig:Crumblizer-with-WS2812B-Strip} on kujutatud WS2812B  tüüpi valgusdioodriba, millele on Crumbliseri abil lisatud Crumble-tüüpi ühendused.

\subsubsection{Mootor}

\fig[0.4]{Pair-of-geared-motors}{Kaks mootorit~\cite{Pair-of-geared-motors}.}

Redfern Electronics toodab ka Crumble’iga ühilduvaid mootoreid~\cite{PairofGearedMotors|RedfernElectronics}. Mootor tuleb ühendada kontrolleril ühte kahest spetsiaalselt mootorite ühendamiseks mõeldud pessa. Joonisel~\ref{fig:Pair-of-geared-motors} on kujutatud kaks mootorit, millel on krokodilljuhtmed, et Crumble’iga lihtsasti ühenduda.

\subsection{4tronix'i toodetud komponendid}

Lisaks Redfern Electronics’ile toodab Crumble’ile komponente ka Ühendkuningriigist pärit firma 4tronix~\cite{Crumble4tronix}.

\fig{4tronix-komponendid}{Firma 4tronix toodetud Crumb’id~\cite{4tronixtoodetavadCrumbid}.}

Joonisel~\ref{fig:4tronix-komponendid} on kujutatud valik 4tronix’i komponentidest Crumble’ile. Kuigi mõned nendest kattuvad Redfern’i enda poolt toodetud komponentidega, siis nendel on oluline disainierinevus. Peaaegu kõigil firma 4tronix toodetud Crumble’ile mõeldud komponentidel on kaks +/- ühenduspaari ning eraldi ühendus(ed) komponendi väljundi(te) jaoks. See võimaldab nende Crumb’e omavahel jadamisi ühendada ning sellega laiendada kontrolleri energiaväljundpesasid. Samuti on need komponendid värvi järgi kategoriseeritud. Kollased komponendid on analoogsisendkomponendid, sinised digitaalsisendkomponendid, punased analoogväljundkomponendid ning mustad digitaalväljundkomponendid. Järgnevalt on välja toodud olulisemad komponendid, mida 4tronix toodab ning mida Redfern ei tooda.

\subsubsection{Kiirendusandur} \label{kiirendus}

Kiirendusandur on seade, millega on võimalik mõõta kiiruse muutumist (kiirendust)~\cite{Kiirendusandur}. Selleks on kiirendusanduri Crumb’il kolm väljundit kolmes dimensioonis kiirenduse lugemiseks: X, Y ja Z~\cite{MotionSensorCrumbAccelerometerforCrumbleController}.

\fig[0.4]{kiirendusandur}{4tronix Crumble’ile loodud kiirendusandur~\cite{Kiirendusandura}.}

Joonisel~\ref{fig:kiirendusandur} on 4tronix’i toodetud kiirendusandur. Selle komponendi plaadi ülalosas on ka toodud joonis näitamaks, mis suunas X, Y ja Z väljundid kiirendust väljastavad.

\subsubsection{Lähedusandur}

\fig[0.4]{proximity-sensor}{4tronix lähedusandur~\cite{Lahedusandur}.}

Lähedusandur (joonisel~\ref{fig:proximity-sensor}) võimaldab tuvastada, kas mingi objekt on anduri lähedal. Komponendil on selle tarbeks infrapunaemitter ja -vastuvõtja, et mõõta lähedal asuva objekti pealt peegelduva infrapunakiirguse intensiivsust ning seeläbi hinnata, kas tema ees on mingi objekt~\cite{ProximitySensorCrumbDigitalInputforCrumbleController}. Kui komponent tuvastab, et tema ees asub lähedal objekt, siis süttib valgusdiood komponendi peal ning väljastatakse digitaalne signaal 1. Anduri tuvastamiskaugus on umbes 2-10 cm olenevalt objektist.

\subsubsection{Puudutusandur}

\fig[0.4]{touch-sensor}{4tronix puudutusandur~\cite{Puudutusandur}.}

Puudutusanduril (joonis~\ref{fig:touch-sensor}) on kaks ala, mille puudutamisel süttib indikaatortuluke ning väljastatakse vastavast väljundist digitaalne signaal 1. Samuti on plaadil ka kaks lisaühendust (märgitud ,,Ext 1'' ja ,,Ext 2''), millega on võimalik laiendada vastavaid puudutusalasid teiste puudutusalade või objektidega (nt puuviljad). Joonisel~\ref{fig:touch-sensor-fruit} on näidatud, kuidas seda on võimalik kasutada.

\fig[0.6]{touch-sensor-fruit}{Puuviljadega ühendatud puudutusandur~\cite{Puuviljadegauhendatudpuudutusandur}.}

Kuigi sellisel puuviljadega ühendamisel on vähe praktilist kasutust, siis on see siiski huvitav ja ebatavaline viis oma projekti juhtimiseks.

\subsubsection{Numbrinäidik}

\fig[0.8]{number-display}{Crumble kontrolleriga ühendatud numbrinäidik~\cite{Crumblekontrollerigauhendatudnumbrinaidik}.}

Numbrinäidik on analoogväljundseade, mis ühendub kontrolleri mootoripesadesse ning väljastab 7-segmendilistel näidikutel numbrit -100-st +100-ni vastavalt mootoripesa väljastatud väärtusele~\cite{NumberDisplayCrumbforCrumbleController}. Negatiivsete arvude kuvamisel süttivad lisaks vastava positiivse numbri kuvamiseks tarvilikud segmendid ka kuvari allääres olevad kaks täppi. Arvu 100 (ja -100) kuvamiseks on kasutatud omapärast lahendust, sest kasutada on vaid kaks numbrinäidikut. Selleks süttivad vasakpoolse näidiku ülemine horisontaalne segment (moodustades horisontaalse numbri 1) ning mõlemal näidikul alumised neli segmenti (moodustades kumbki numbri 0). Negatiivse arvu 100 puhul süttivad ka täpid näidiku allääres. Suuremate arvude kui 100 ja väiksemate arvude kui -100 kuvamise reeglid pole üheselt määratud. Joonisel~\ref{fig:number-display} on kujutatud numbrit 99 kuvav numbrinäidik.

\subsubsection{Passiivne infrapunasensor}

\fig[0.6]{PIR-sensor}{Crumble kontrolleriga ühendatud passiivne infrapunasensor~\cite{Passiivneinfrapunasensor}.}

Passiivne infrapunasensor (joonisel~\ref{fig:PIR-sensor}) mõõdab muutusi ümbritsevas infrapunakiirguses ning võimaldab sellega tuvastada muuhulgas inimeste liikumist~\cite{PIRSensorCrumbDigitalInputforCrumbleController}. Liikumise tuvastamisel väljastab sensor digitaalse signaali 1.

\subsubsection{Servomootor} \label{servo}

\fig[0.3]{servo}{4tronix servomootor~\cite{Servomootor}.}

Servomootor erineb tavalisest mootorist selle poolest, et kui signaali saamisel tavaline mootor pöörleb pidevalt, siis servomootor pöörab end vastavalt sisendsignaaline kindlasse asendisse ja üritab seda asendit säilitada~\cite{Servomootorroboticlab}. 4tronix servomootor (joonisel~\ref{fig:servo}) võimaldab võtta asendi -90 ja 90 kraadi vahel~\cite{ServoCrumbforCrumbleController}.

\subsubsection{PlayGround} \label{playground}

PlayGround (joonis~\ref{fig:playground}) on 4tronix’i loodud terminalplokk selleks, et Crumble (ja Micro:Bit) komplekte mugavamalt kasutada~\cite{PlaygroundforCrumbleBlog}. Crumble kontroller ühendub kruvidega PlayGround plaadi külge. Plaadi all on kontrolleri toiteks patereipakk ning külgedel erinevad sisend-väljundpesad.

\fig{playground}{PlayGround, Gizmod ja juhtmed~\cite{PlayGroundGizmodjajuhtmed}.}

4tronix kirjutab oma blogisissekandes~\cite{PlaygroundforCrumbleBlog}, et PlayGroundi teeb eriliseks see, et lisaks tavalistele Crumble-tüüpi ühendustele on nad lisanud ka 3,5-millimeetrised pesad, mis on paremini tuntud ka kui pesad kõrvaklapijuhtmete ühendamiseks. Nendes pesades on ühte kokku toodud kolm Crumble-tüüpi pesa: energia sisend-väljnud ning signaal. See võimaldab projekte oluliselt paremini organiseerida, sest tavalise kolme juhtme asemel iga Crumb’i kohta on võimalik sama tulemust saavutada ühe juhtmega ning kõrvaklapijuhtmete ühendamine om palju lihtsam kui krokodilljuhtmete ühendamine. 

4tronix on loonud paljudest juba nende toodetud Crumb’idest spetsiaalselt PlayGroundile mõeldud versioonid (Gizmod), millel on Crumble-tüüpi pesade asemel 3,5-millimeetrised pesad PlayGroundiga (või teiste Gizmodega) ühendumiseks. Lisaks pakuvad nad ka prototüüpimise Gizmot (joonisel all paremal), millega on võimalik ise luua PlayGroundiga ühenduv Gizmo~\cite{PrototypingGizmoforPlayground-MakeyourownGizmo}.


\subsection{Arenduskeskkond ja -protsess} \label{tarkvara}

Crumble’ile programmide loomiseks on tarvis mikrokontroller USB kaudu arvutiga ühendada. Samuti on vajalik alla laadida ja arvutisse paigaldada Crumble tarkvara\footnote{Kättesaadav aadressil \url{http://redfernelectronics.co.uk/crumble-software/}}.

Crumble tarkvara on MIT Scratchist inspireeritud keskkond Crumble’i programmide arendamiseks~\cite{TheCrumbleController}. Sarnaselt Scratchile luuakse programme erinevate plokkide kokkuvedamisega. Iga plokk on vastavalt oma tüübile kindla kujuga ning plokkidel võivad olla ka kindla kujuga augud, kuhu saab teisi plokke sisestada. Kõik käsud on pusletükikujulised ning sobituvad üksteise järele, tõeväärtused on kuusnurgad ning arvud ja muutujad ümardatud otstega ristkülikud.

\fig{crumble-software}{Crumble tarkvara.}

Joonisel~\ref{fig:crumble-software} on näidatud Crumble tarkvara koos lihtsa programmiga, mis seab kõik Sparkle’id punaseks. Vasakul ääres on valik plokke erinevates kategooriates: ,,Basic'' (enimkasutatavad), ,,Input/Output'' (sisend-väljnud), ,,Sparkles'' (Sparkle’id), ,,Control'' (programmi juhtplokid), ,,Variables'' (muutujad) ja ,,Operators'' (tehted).

Tarkvaral on kaks nuppu: roheline kolmnurk ja punane ruut. Roheline nupp laadib praeguse programmi USB ühenduse kaudu Crumble kontrollerisse ning käivitab selle. Punane nupp peatab hetkel jooksva programmi. Samuti on võimalik rippmenüüst ,,File'' Crumble programme arvutisse salvestada ja sealt uuesti laadida.

Iga programm peab koosnema täpselt ühest ,,Program start'' plokist. See plokk tähistab programmi alguse kohta, seega kogu programmi tegevus algab sealt. Järgnevalt on toodud kategooriate kaupa kõikide plokkide kirjeldused.

\subsubsection{Sisend-väljundplokid}

\fig[0.3]{input-output}{Sisend-väljundplokkide nimekiri.}

Sisend-väljundplokid (joonisel~\ref{fig:input-output}) võimaldavad digitaalselt ja analoogiliselt lugeda ja digitaalselt kirjutada kontrolleri A, B, C ja D pesadele. Kirjutamiseks on ,,set'' plokk, mis võimaldab valitud pesalt väljastada digitaalse signaali 1 või 0 (HI või LO). 

\fig[0.3]{motorblock}{,,Motor'' ploki kolm seadistust}


,,Motor'' plokk juhib mootoripesasid. Võimalik on valida pesa 1 või 2 vahel ning kas mootor peatada, edasi liikuda või tagasi liikuda (vastavalt ,,STOP'', ,,FORWARD'' ja ,,REVERSE'', vt joonis~\ref{fig:motorblock}) ning kui kiiresti protsendina 0-st 100-ni.

,,Servo'' plokiga on võimalik seada kindel servomootor (vt~\ref{servo}) mingisse teatud asendisse. Tuleks tähele panna, et servomootor ei ühendu mootoripesadega vaid väljundpesaga A, B, C või D (lisaks energiaväljundile).

,,(A/B/C/D) is (HI/LO)'' plokk tagastab, kas valitud sisendpesast tulev signaal on sees või mitte. Näiteks ,,A is HI'' plokk tagastaks tõese väärtuse, kui pesaga A ühendatud nuppu all hoitakse.

,,Analogue (A/B/C/D)'' plokki kasutatakse analoogsignaali saamiseks valitud pesast. See on kasulik, kui Crumb’i tagastatud väärtus on pidev suurus ning mitte kas 0 või 1. Analoogsignaal kajastub koodis arvuna 0-st 255-ni. Seda kasutatakse näiteks kiirendusanduri (vt~\ref{kiirendus}) puhul.

,,Distance'' plokk on ultraheli kaugusandurilt (vt~\ref{kaugusandur}) tema vastas oleva objekti kauguse teada saamiseks. Selleks tuleb anduri T ja E ühendused ühendada kontrolleriga ning ,,distance'' plokis ära määrata. Plokk tagastab andurilt saadud kauguse sentimeetrites.

\subsubsection{Sparkle'ite juhtimisplokid}

\fig[0.3]{sparkles}{Sparkle'ite juhtimisplokkide nimekiri.}

Kõiki Sparkle’eid on võimalik nii korraga kui ka individuaalselt muuta kindlaks värviks. Selleks on plokid ,,set sparkle to'' ning ,,set all sparkles to''. Esimene seab kindla Sparkle’i kindlaks värviks ning teine teeb sama kõikide Sparkle’itega. Nendest plokkidest on Crumble tarkvaras kaks varianti: värvivalimisdialoogiga variant (joonisel~\ref{fig:sparkles} esimene ja kolmas plokk), mis võimaldavad kasutajal spetsiaalse akna abil valida sobiv värv, ning RGB väärtustega variant (viies ja kuues plokk joonisel), kus kasutaja saab määrata punase, rohelise ja sinise värvi intensiivsuste (vahemikus 0 kuni 255) kombinatsiooniga Sparkle’i värvi. Plokid ,,turn sparkle off'' ja ,,turn all sparkles off'' lülitavad vastavalt ühe kindla või kõik Sparkle’id välja.


\subsubsection{Juhtplokid}

\fig[0.3]{control}{Juhtplokkide nimekiri.}

Juhtplokid (joonisel~\ref{fig:control}) võimaldavad programmi tööd juhtida vastavalt teatud tingimustele. ,,Wait seconds'' ja ,,wait milliseconds'' plokid ootavad vastavalt mingi arvu sekundeid või millisekundeid enne järgmise käsu täitmist. ,,Wait until'' plokk peatab programmi töö nii kaua kuni teatud tingimus on täidetud. ,,If then'' ning ,,If then else'' plokid võimaldavad mingi tingimuse kohaselt käivitada või mitte käivitada koodiplokke. ,,Do until'', ,,do X times'' ja ,,do forever'' plokid 
võimaldavad koodiplokke korduvalt käivitada vastavalt mingi tingimuse täitumiseni, täpselt X korda või lõpmatu arv kordi.

\subsubsection{Muutujaplokid}

\fig[0.25]{variables}{Muutujaplokkide nimekiri.}

Muutujaplokid (joonisel~\ref{fig:variables}) võimaldavad luua muutujaid, seada neile väärtuseid ning nende väärtuseid lugeda. ,,Let'' plokk seab muutujale väärtuse. Muutuja plokk tuleb tõmmata ,,Add New Variable'' nupu all olevatest muutujaplokkidest. Algselt on olemas muutujaplokid nimedega ,,t'', ,,u'', ,,v'', ,,w'', ,,x'', ,,y'' ja ,,z'', kuid neid on võimalik kustutada (nupuga ,,del''), ümber nimetada (nupuga ,,rename'') ning juurde lisada (nupuga ,,Add New Variable''). ,,Increase by'' plokk 
lisab muutuja väärtusele mingi arvu. ,,Decrease by'' plokk vähendab muutuja väärtust mingi arvu võrra.

\fig[0.25]{variable-value}{Muutuja ,,t'' väärtus on 45.}

Programmi jooksmise ajal on võimalik kõigi muutujate väärtuseid muutujaplokkide nimekirjas näha. Joonisel~\ref{fig:variable-value} on näha, et muutuja ,,t'' väärtuseks on 45. Teiste muutujate väärtused on ,,?'', sest nendele pole programmi töös määratud väärtust.

\subsubsection{Tehteplokid}

\fig[0.25]{operators}{Tehteplokkide nimekiri.}

Tehteplokid (joonis~\ref{fig:operators}) võimaldavad teha programmi töös esinevate väärtustega aritmeetilisi ja loogilisi operatsioone. Aritmeetikast on võimaldatud liitmine, lahutamine, korrutamine ja jagamine, kusjuures jagamine on täisarvuline jagamine, kus vastuseks on vaid täisosa ning jääk visatakse minema. See on põhjustatud sellest, et Crumble ei võimalda ujukomaarvudega töötamist. Loogilistest operatsioonidest on võimaldatud võrdus, mittevõrdus, ,,suurem kui'', ,,väiksem kui'', ,,ja'', ,,või'' ning ,,mitte''. Lisaks on tehteplokina toodud ka ,,random'' plokk, mis tagastab suvalise täisarvu etteantud vahemikus (mõlemad otspunktid kaasaarvatud).

\subsection{Arhitektuur}

Crumble kontroller kasutab oma protsessoriks PIC16F1455\footnote{\url{http://www.microchip.com/wwwproducts/en/PIC16F1455}} tüüpi mikrokontrollerit. Sellel on 14 KB mälu programmide salvestamiseks ning 1024 baiti sisemälu~\cite{PIC16F1455}. Komponentide juhtimiseks on Redfern Electronics loonud kontrollerile oma masinkoodi. Katse-eksitus meetodil ning Crumble tarkvara lähtekoodi lugedes leitud masinkoodi käsud ja nende kirjeldused on toodud lisas~\ref{masinkoodi-käsud}. 


Käsu enda argumendid (näiteks käsu ,,\texttt{POP} $a$'' puhul $a$) kodeeritakse koos käsu koodiga otse masinkoodi sisse. Käsu kood on tabelis esitatud kuueteistkümnendsüsteemi arvuna grupeeritud baitide kaupa. See on käsu numbriline esitus, mida Crumble protsessor lugeda ja millele vastavalt käituda oskab. Käsu argumendi kodeerimiseks lühendatakse see ühe baidi (kümnendüsteemi arv vahemikus $0$ kuni $255$) pikkuseks ning liidetakse otse käsu koodile. Näiteks käsu ,,\texttt{POP} 45'' masinkoodi esitusviis oleks ,,\texttt{03~2D}'', sest ,,\texttt{POP}'' masinkoodis on \texttt{03 00} (vt lisa \ref{masinkoodi-käsud}), $45$ kuueteistkümnendsüsteemis on \texttt{2D} ning $\texttt{03 00} + \texttt{2D} = \texttt{03 2D}$. Samuti on paljudel käskudel olemas ka pinu argumendid. Pinu argumendid salvestatakse programmi töö käigus protsessori pinusse, mille pealt käsud oma argumente loevad ning tagastusväärtuse olemasolul ka selle pinusse kirjutavad. Loogikatehete puhul (näiteks ,,\texttt{OR}'' või ,,\texttt{AND}'') loetakse tõeseks väärtuseks kõike, mis ei ole $0$.

Lisas~\ref{masinkoodi-käsud} toodud käsud on madalaima taseme ehituskivid Crumble'ile programmide loomiseks. Nende kombineerimisel kõrgema taseme funktsionaalsusteks põhineb nii Crumble tarkvara kui ka järgmises peatükis kirjeldatud ning töö eesmärgina loodav programmeerimiskeel Crumblepy.

\section{Crumblepy} \label{crpy}

Crumblepy\footnote{Kättesaadav aadressil \url{https://github.com/rasmussaks/crumblepy}} on käesoleva töö raames loodud Pythonil põhinev programmeerimiskeel, millega on võimalik juhtida Crumble kontrolleri tööd. Järgnevad peatükid kirjeldavad nii Crumblepy ehitust ja mis valikuid selleni jõudmiseks tehti kui ka tööprotsessi sellega töötamisel.

\subsection{Arhitektuur}

Kuigi Crumble tarkvara on loodud Python 2-s, siis Crumblepy on kirjutatud Python 3-s. See erinevus tuleneb põhiliselt sellest, et Pythoni loojad ise soovitavad uute projektide alustamisel kasutada Pythoni kolmandat versiooni, sest see on paljudes aspektides parem kui Python 2~\cite{Python2orPython3-PythonWiki}. Lisaks sellele on autor tuttavam Python 3-ga kui Python 2-ga. Kuna Crumblepy põhineb Crumble tarkvara lähtekoodil, siis on tarvis Python 2-s kirjutatud kood ümber teisendada vastavaks Python 3 koodiks. 

Failis ,,crumblepy/usb.py'' on kokku pandud Redfern Electronics'i loodud Pythoni kood Crumble'iga suhtlemiseks USB kaudu, mis on ümber teisendatud Python 3-e. Antud juhul oli tarvis teha vähe muudatusi, et algne kood jookseks sama moodi Python 3-l, kui ta jooksis Python 2-l. Põhilised erinevused tulenesid täisarvude jagamisel\footnote{Kahe täisarvu jagamine Python 2-s tagastab täisarvu ($5/2 = 2$), Python 3-s aga ujukomaarvu ($5/2 = 2.5$)~\cite{KeyDifferences}} ning generaatorobjektide või listide tagastamisel\footnote{Python 2-s tagastasid paljud sisseehitatud funktsioonid (nt \python{range()} ja \python{dict().keys()}) list-tüüpi objekte, kuid Python 3-s tagastavad need generaatorobjekte~\cite{KeyDifferences}}.

Crumblepy on loodud olema algajatele võimalikult lihtne viis riistvaraprogrammeerimisega tegelemiseks. Seetõttu valiti Crumblepy keele põhjaks just Python, mida tihti õpetatakse koolides esimese programmeerimiskeelena. Samuti teeb Pythoni standardteek Pythoni parsimise väga lihtsaks, pakkudes selleks \python{ast} moodulit \cite{PythonAST}. Mooduli funktsioon \python{ast.parse()} võimaldab parsida sisendsõne Pythoni abstrakseks süntaksipuuks nagu on näidatud joonisel~\ref{astparse}.

\begin{figure}[ht]
	\pythonfile{ast.parse.py}
	\caption{Faili parsimine abstraktseks süntaksipuuks}
	\label{astparse}
\end{figure}

Tulemuseks on puu, mille tipud on Pythoni süntaksielemendid, mis on täielikult kirjeldatud Pythoni dokumentatsiooni peatükis 32.2.2\footnote{\url{https://docs.python.org/3/library/ast.html#abstract-grammar}}. Selle puu rekursiivse läbimisega on võimalik kompileerida Pythonil põhinev sisendkood Crumble kontrollerile mõistetavaks masinkoodiks.

Crumble'i masinkoodi piirangute tõttu ei ole võimalik kõiki Pythoni keele võimalusi kompileerida, mistõttu on paljud nendest välja jäetud ning annavad kompileerimisel veateate. Sinna kuuluvad näiteks ujukomaarvud, andmetüübid \python{list} ja \python{dict} ning palju muud. Crumblepy keele võimalustest on kirjutatud peatükis \ref{keele-võimalused}.

\subsection{Kompilaator}

Crumblepy kompilaator (failis ,,crumblepy/compiler.py'') kasutab Pythoni \python{ast} moodulit, et saada sisendfaili abstraktne süntaksipuu ning seejärel muundab selle Crumble kontrollerile arusaadavaks masinkoodiks. Vahelüliks masinkoodi ja Crumblepy koodi vahel on assemblerkood, mis on inimloetav masinkood. Joonisel \ref{denable} on toodud Crumblepy kood, mis väljastab signaali $1$ pesast D, ning joonisel \ref{denable-assembly} on sama kood esitatud assemblerkoodis, kuhu on lisatud kommentaarid iga rea ülesande kohta.

\begin{figure}[ht]
	\pythonfile{d-enable.crpy}
	\caption{Python kood väljundpesa D sisselülitamiseks}
	\label{denable}
\end{figure}

\begin{figure}[ht]
	\inputminted{text}{d-enable-asm.crpy}
	\caption{Kommenteeritud assemblerkood väljundpesa D sisselülitamiseks}
	\label{denable-assembly}
\end{figure}

Erinevalt lähtekoodist, kompileeritakse iga assemblerkoodi käsk üheks (välja arvatud mõnel erandjuhul kaheks) masinkoodi käsuks. Joonisel \ref{denable} on üks lähtekoodi käsk \python{set_output(D, 1)}, mis masinkoodis esitatakse kolme käsuga: kaks käsku argumentide pinusse panemiseks ning üks käsk väljundpesa väljundi seadmiseks vastavalt pinust loetud väärtustele.

Joonisel~\ref{ast-code} on toodud kood, mis seab pesa A väljundiks pesa C signaali, kui pesa D signaal on 1, või signaali 0, kui pesa D signaal ei ole 1.

\begin{figure}[ht]
	\pythonfile{ast-example.crpy}
	\caption{Crumblepy kood pesa A väljundi seadmiseks vastavalt pesa D signaalile}
	\label{ast-code}
\end{figure}

Joonisel~\ref{ast-tree} on kujutatud joonisel~\ref{ast-code} toodud Crumblepy koodi abstraktne süntaksipuu, mis on saadud funktsiooni \python{ast.parse()} kasutamisel antud koodi peal.

\begin{figure}[ht]
	\centering
	\shorthandoff{"}
	\begin{forest}
		lbl/.style={%
			edge label={node [midway, sloped, above, font=\scriptsize] {\ttfamily#1}}
		},
		for tree = {font=\ttfamily}
		[Module
			[IfExp
				[Compare
					[Call
						["get\_analog"]
						[Name ["D"]]
					]
					[Eq]
					[Num
						[1]
					]
				]
				[Call
					["set\_output"
						[Name ["A"]]
						[Call
							["get\_output"]
							[Name ["C"]]
						]
					]
				]
				[Call
					["set\_output"
						[Name ["A"]]
						[Num [0]]
					]
				]
			]
		]
	\end{forest}
	\shorthandon{"}
	\caption{Abstraktne süntaksipuu}
	\label{ast-tree}
\end{figure}

Abstraktne süntaksipuu on koodi süntaktilise struktuuri esitus puuna. See võimaldab programmiliselt väikese vaevaga kompileerida Crumblepy lähtekood Crumble kontrolleri masinkoodiks. Joonisel~\ref{compiler-example} on väljavõte Crumblepy kompilaatori tuumast, rekursiivsest abstraktse süntaksipuu läbijast. Iga Pythoni abstraktse süntaksipuu juurtipuks on \texttt{Module}, millest hargnevad alamtipud vastavalt programmi sisule.

\begin{figure}[ht]
	\pythonfile{compiler-example.py}
	\caption{Rekursiivne süntaksipuu läbimine}
	\label{compiler-example}
\end{figure}

Funktsioon \python{compile_stmt} võtab argumendina sisse abstraktse süntaksipuu juurtippu (\texttt{Module} tüüpi tipu) ning läbib rekursiivselt iga puu tipu ning väljastab iga tipu kohta sellele vastava(d) masinkoodi käsu(d). Joonisel~\ref{set-output} on toodud Crumblepy funktsiooni \python{set_output(pesa, signaal)} kompileeriv funktsioon.

\begin{figure}[ht]
	\pythonfile{set-output.py}
	\caption{Crumblepy funktsiooni \python{set_output(pesa, signaal)} kompileeriv funktsioon}
	\label{set-output}
\end{figure}

Funktsioon \python{self.compile_expr(node)} kompileerib antud avaldise tipu sellele vastavaks masinkoodiks. Muutuja \python{self.assembly} on viide \python{crumblepy.Assembly} klassile, kus on abifunktsioonid lisas~\ref{masinkoodi-käsud} esitatud masinkoodikäskudega töötamiseks. Näidiskoodis joonisel~\ref{set-output} väljastab \python{self.assembly.dwr()} masinkoodi käsu \texttt{DWR}, mis loeb kahe eelneva \python{self.compile_expr(node)} käsu poolt pinusse pandud argumendid - pesa number ja signaali väärtus - ning väljastab antud pesast määratud signaali.

Erinevalt Crumble tarkvarast puuduvad Crumblepy'l argumentidele ranged piirangud, mis võimaldavad Crumblepy keeles väljendada palju keerukamaid programme kui Crumble tarkvaras. Crumble tarkvara piirab näiteks funktsiooni ,,set'' argumendid olema täpselt ,,A'', ,,B'', ,,C'' või ,,D'' ning ,,HI'' või ,,LO''. Crumblepy selliseid piiranguid ei sea, mis tähendab, et joonisel~\ref{ast-code} olev kood on Crumblepy's lubatud, kuid Crumble tarkvaras mitte, sest seal kasutatakse ühe pesa väärtust teise pesa sisendina, mida Crumble tarkvaras ei ole võimalik teha.

\subsection{Keele võimalused} \label{keele-võimalused}
Järgnevates peatükkides on välja toodud kõik funktsionaalsused, mida Crumblepy keel toetab. Kuigi keel põhineb Pythonil, ei ole võimalik kõiki Pythoni võimalusi Crumble kontrolleri masinkoodis väljendada, mistõttu on esindatud vaid kindel alamhulk Pythoni funktsionaalsusest.

\subsubsection{Funktsioonid}
Crumblepy's on võimalik kasutada erinevaid funktsioone Crumble'i juhtimiseks. Kõik funktsioonid käituvad identselt vastavatele funktsioonidele Crumble tarkvaras ning on esitatud tabelis~\ref{functions-table}.

\LTXtable{\linewidth}{functions-table.tex}

Pesade identifikaatoritena võib kasutada nii numbreid $0$, $1$, $2$, $3$ (vastavalt pesad ,,A'', ,,B'', ,,D'', ,,C'') kui ka sisse ehitatud muutujaid \python{A}, \python{B}, \python{C}, \python{D}.

\subsubsection{Tingimuslaused}
Crumblepy toetab täielikult Pythoni tingimuslauseid (\python{if}-lauseid). Joonisel~\ref{if-code} on toodud näide \python{if}-\python{else} konstruktsioonist ning joonisel~\ref{if-code-asm} on toodud sama koodi esitus masinkoodis koos selgitavate kommentaaridega.

\begin{figure}[!ht]
	\pythonfile{if-code.crpy}
	\caption{\python{if}-\python{else} konstruktsioon Crumblepy koodina}
	\label{if-code}
\end{figure}


\inputminted{text}{if-code-asm.crpy}
\captionof{figure}{\python{if}-\python{else} konstruktsioon Crumble'i masinkoodina\label{if-code-asm}}
~

Crumblepy's kasutab \python{if}-lause märgendeid, et vastavalt tingimuse kehtimisele hüpata kas \python{if}-haru või \python{else}-haru sisse. Tingimuseks võivad olla kõigi funktsioonide tagastusväärtused. Tõeseks väärtuseks loetakse kõike, mis ei ole $0$. Vääraks väärtuseks loetakse $0$. Samuti on võimalik kasutada loogilisi konstante \python{True} ja \python{False}, mis aga Crumble masinkoodis loogilise tüübi puudumise tõttu kompileeritakse vastavalt arvudeks $1$ ja $0$.

\subsubsection{Tsüklid}
Crumblepys on võimalik kasutada vaid \python{while}-tsüklit. Toetatud on ka \python{continue} ja \python{break} laused vastavalt tsükli järgmisele iteratsioonile hüppamiseks ning tsükli lõpetamiseks. Pythoni \python{for}-tsüklit ei ole võimalik kasutada Crumble masinkoodis \python{list} tüübi puudumise tõttu.

\subsubsection{Muutujad}
Muutujate väärtustamine ja kasutamine toimub Crumblepys identselt Pythonile. Joonisel~\ref{var-example} on näidatud Crumblepys muutujale väärtuse andmine.

\begin{figure}[!ht]
	\pythonfile{var-example.crpy}
	\caption{Muutuja väärtustamine Crumblepys}
	\label{var-example}
\end{figure}

Erinevus Pythonist seisneb vaid võimalikes muutujatüüpides. Võimalik on kasutada vaid täisarve ja tõeväärtusi (\python{int} ja \python{bool}). Kusjuures tõeväärtused kompileeritakse täisarvudeks $1$ ja $0$ (vastavalt \python{True} ja \python{False}). See tähendab, et näiteks \python{True + 3} Crumblepy koodis on võrdne arvuga $4$.

Samuti on reserveeritud neli muutujat \python{A}, \python{B}, \python{C} ja \python{D} vastavalt täisarvuliste väärtustega $0$, $1$, $3$ ja $2$, et oleks võimalik lihtsamalt viidata pesadele funktsioonides, mis vajavad pesa identifikaatoreid. Neid muutujaid ei ole lubatud üle kirjutada. See toob kaasa kompileerimisel veateate. Pesade identifikaatoritena on võimalik kasutada ka nende muutujate endi täisarvulisi väärtusi. Järgmised kaks koodijuppi on seega võrdväärsed: \python{get_digital(A)} ja \python{get_digital(0)}.

\subsection{Kompilaatori kasutamine}
Crumblepy kompilaator on loodud olema käsurealt kasutatav. Käsurea parsimiseks kasutatakse \python{argparse} moodulit. Parsimine toimub failis \hbox{,,crumblepy/\_\_init\_\_.py''} Kompilaatori käsureaargumendid on nähtavad, kirjutades käsureal \mintinline{text}{python crumblepy -h}. Selle käsu tulemus on näidatud joonisel~\ref{cmd-args}.


\inputminted{text}{cmd-args.txt}
\captionof{figure}{Crumblepy kompilaatori käsureaargumendid}\label{cmd-args}
~

Käsul on üks kohustuslik argument \textinline{file}, mis määrab Crumblepy lähtekoodi faili, mida kompilaator peab kompileerima. Võimalik on määrata argumendiga \textinline{--format} väljundi tüüp. Väljundi tüüp \textinline{bytecode} väljastab koodi baitide nimekirjana, \textinline{assembly} väljastab koodi assemblerkoodina, \textinline{usb} saadab kompileeritud masinkoodi USB ühenduse kaudu Crumble kontrollerile. Kasutades argumenti \textinline{--output}, on võimalik määrata, et konsooli trükkimise asemel salvestataks väljund faili. Kui on määratud \textinline{--format usb} (mis on ka vaikeväärtuseks), siis \textinline{--output} ei tee midagi.

\subsection{Testimine}



Crumblepy kompilaatori testimiseks on loodud programmid, mille eesmärgiks on testida kõiki kompilaatori funktsionaalsusi. Need programmid asuvad kaustas \hbox{,,test/crpy\_sources''}. Iga programmi päises on kommentaar testitava funktsionaalsuse kirjelduse ning oodatud tulemusega. Testi jooksutamiseks on tarvis Crumble ning sobivad Crumb'id ja Sparkle'id vastavalt testi kirjeldusele ja oodatud tulemusele omavahel ühendada ning Crumble kontroller USB kaudu arvutiga ühendada. Peale seda tuleks kompileerida testskript ning see saata USB kaudu Crumble kontrollerile. 

\begin{figure}[!ht]
	\inputminted{text}{testing-example.txt}
	\caption{Testskripti kompileerimine ja Crumble kontrollerile saatmine}
	\label{testing-example}
\end{figure}

Joonisel~\ref{testing-example} on näidisena toodud testskripti \hbox{,,test/crpy\_sources/d\_enable.crpy''} kompileerimine ning kontrollerile saatmine Crumblepy kompilaatori käsu abil. Kui Crumble käitub vastavalt testi päises toodud oodatud tulemusele, siis on test edukalt läbitud.

\section*{Kokkuvõte}
\addcontentsline{toc}{section}{Kokkuvõte}
Käesoleva bakalaureusetöö eesmärgiks oli luua Crumble kontrollerile programmeerimiskeel, mis põhineb keelel Python. Töös anti ülevaade Crumble kontrollerist, sellega ühilduvatest komponentidest ning Crumble'i arenduskeskkonnast ja -protsessist. Loodi Pythoni baasil programmeerimiskeel Crumblepy, millega on võimalik Crumble kontrollerit juhtida, ning anti ülevaade selle loomisprotsessist. Samuti kirjeldati Crumblepy'ga töötamist: keele funktsionaalsusi ning selle kompileerimist.

Valminud programmeerimiskeel ja selle kompilaator võimaldavad Pythoni-sarnase keelega Crumble kontrollerit juhtida. Sarnasus Pythoniga toetab algaja Pythonis programmeerija edasisi õpinguid paremini kui Crumble'i enda arenduskeskkond. Käesolevat tööd oleks võimalik edasi arendada, luues valiku õppematerjale või projekte, mida Crumblepy'd kasutades oleks võimalik koolitundides kasutada.

\selectlanguage{estonian}
\printbibliography[heading=bibintoc,title={Viidatud kirjandus}]
\section*{Lisad}
\addcontentsline{toc}{section}{Lisad}
\setcounter{section}{0}
%\renewcommand{\thesection}{\Roman{section}}
\section{Crumble kontrolleri masinkoodi käsud} \label{masinkoodi-käsud}
\LTXtable{\linewidth}{machinecode-table.tex}
\newpage
\section{Litsents}
Mina, \textbf{Rasmus Saks}
\begin{enumerate}
	\item annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose ,,\textbf{Crumble kontrollerile Pythoni-laadse programmeerimiskeele loomine}'', mille juhendaja on \textbf{Aivar Annamaa}
	\begin{enumerate}[label*=\arabic*.]
		\item reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja lõppemiseni
		\item üldsusele kättesaadavaks tegemiseks Tartu Ülikooli veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace'i kaudu kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
	\end{enumerate}
	\item olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
	\item kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi.
\end{enumerate}


Tartus, \textbf{\today}
\newpage

\end{document}

